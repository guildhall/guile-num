(define-module (gsl gsl)
  :use-module (gsl gsl-errno)
  :use-module (gsl gsl-math)
  :use-module (gsl gsl-block)
  :use-module (gsl gsl-vector)
  :use-module (gsl gsl-matrix)
  :use-module (gsl gsl-blas)
  :use-module (gsl gsl-poly)
  :use-module (gsl gsl-combination)
  :use-module (gsl gsl-fft)
  :use-module (gsl gsl-eigen)
  :use-module (gsl gsl-linalg)
  :use-module (gsl gsl-permute)
  :use-module (gsl gsl-rng)
  :use-module (math array-fun))

(export complex->gsl-complex
	gsl-complex->complex
	vector->gsl-vector-int
	gsl-vector-int->vector
	vector->gsl-vector
	gsl-vector->vector
	vector->gsl-vector-complex
	gsl-vector-complex->vector
	matrix->gsl-matrix-int
	gsl-matrix-int->matrix
	matrix->gsl-matrix
	gsl-matrix->matrix
	matrix->gsl-matrix-complex
	gsl-matrix-complex->matrix
	blas-dgemv
	blas-zgemv
	blas-dgemm
	blas-zgemm
	ddot
	zdotu
	zdotc
	dot
	real-poly-eval
	real-poly-solve)

;;; Complex number conversion functions
(define (complex->gsl-complex x)
  (let ((z (gsl-complex-alloc)))
    (gsl-set-complex z (real-part x) (imag-part x))))

(define (gsl-complex->complex z)
  (+ (gsl-real z) (* +i (gsl-imag z))))

;;; Vector conversion functions
(define (vector->gsl-vector-int v)
  (let* ((len (uniform-vector-length v))
	 (w (gsl-vector-int-calloc len)))
    (do ((i 0 (+ i 1)))
	((= i len) w)
      (gsl-vector-int-set w i (uniform-vector-ref v i)))))

(define (gsl-vector-int->vector v)
  (let* ((len (gsl-vector-int-length v))
	 (w (make-uniform-vector len -1)))
    (do ((i 0 (+ i 1)))
	((= i len) w)
      (uniform-vector-set! w i (gsl-vector-int-get v i)))))

(define (vector->gsl-vector v)
  (let* ((len (uniform-vector-length v))
	 (w (gsl-vector-calloc len)))
    (do ((i 0 (+ i 1)))
	((= i len) w)
      (gsl-vector-set w i (uniform-vector-ref v i)))))

(define (gsl-vector->vector v)
  (let* ((len (gsl-vector-length v))
	 (w (make-uniform-vector len 1/3)))
    (do ((i 0 (+ i 1)))
	((= i len) w)
      (uniform-vector-set! w i (gsl-vector-get v i)))))

(define (vector->gsl-vector-complex v)
  (let* ((len (uniform-vector-length v))
	 (w (gsl-vector-complex-calloc len))
	 (z (gsl-complex-alloc)))
    (do ((i 0 (+ i 1)))
	((= i len) w)
      (let* ((z (uniform-vector-ref v i))
	     (re (real-part z))
	     (im (imag-part z)))
	(gsl-vector-complex-set-real-imag w i re im)))))

(define (gsl-vector-complex->vector v)
  (let ((w (make-uniform-vector (gsl-vector-complex-length v) 0+i)))
    (do ((i 0 (+ i 1)))
	((= i (gsl-vector-complex-length v)) w)
      (let ((z (gsl-vector-complex-get v i)))
	(uniform-vector-set! w i (gsl-complex->complex z))))))

;;; Matrix conversion functions
(define (matrix->gsl-matrix-int v)
  (let* ((rows (car (array-dimensions v)))
	 (cols (cadr (array-dimensions v)))
	 (w (gsl-matrix-int-calloc rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(gsl-matrix-int-set w i j (array-ref v i j))))))

(define (gsl-matrix-int->matrix v)
  (let* ((rows (gsl-matrix-int-rows v))
	 (cols (gsl-matrix-int-cols v))
	 (w (make-uniform-array -1 rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(array-set! w (gsl-matrix-int-get v i j) i j)))))

(define (matrix->gsl-matrix v)
  (let* ((rows (car (array-dimensions v)))
	 (cols (cadr (array-dimensions v)))
	 (w (gsl-matrix-calloc rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(gsl-matrix-set w i j (array-ref v i j))))))

(define (gsl-matrix->matrix v)
  (let* ((rows (gsl-matrix-rows v))
	 (cols (gsl-matrix-cols v))
	 (w (make-uniform-array 1/3 rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(array-set! w (gsl-matrix-get v i j) i j)))))

(define (matrix->gsl-matrix-complex v)
  (let* ((rows (car (array-dimensions v)))
	 (cols (cadr (array-dimensions v)))
	 (w (gsl-matrix-complex-calloc rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(let* ((z (array-ref v i j))
	       (re (real-part z))
	       (im (imag-part z)))
	  (gsl-matrix-complex-set-real-imag w i j re im))))))

(define (gsl-matrix-complex->matrix v)
  (let* ((rows (gsl-matrix-complex-rows v))
	 (cols (gsl-matrix-complex-cols v))
	 (w (make-uniform-array 0+i rows cols)))
    (do ((i 0 (+ i 1)))
	((= i rows) w)
      (do ((j 0 (+ j 1)))
	  ((= j cols))
	(let ((z (gsl-matrix-complex-get v i j)))
	  (array-set! w (gsl-complex->complex z) i j))))))


;;; Matrix - vector multiplication
(define (blas-dgemv trans alpha A x beta y)
  (if (not (real? alpha))
      (error "alpha must be a real number"))
  (if (not (real-matrix? A))
      (error "A must be a real matrix"))
  (if (not (real-vector? x))
      (error "x must be a real vector"))
  (if (not (real? beta))
      (error "beta must be a real number"))
  (if (not (real-vector? y))
      (error "y must be a real vector"))
  (let* ((trans (cond ((eq? trans 'no-transpose) (CblasNoTrans))
		      ((eq? trans 'transpose) (CblasTrans))
		      ((eq? trans 'conjugate) (CblasConjTrans))
		      (else (error "unknown trans parameter"))))
	 (A (matrix->gsl-matrix A))
	 (x (vector->gsl-vector x))
	 (y (vector->gsl-vector y))
	 (errno (gsl-blas-dgemv trans alpha A x beta y))
	 (result (gsl-vector->vector y)))
    (gsl-matrix-free A)
    (gsl-vector-free x)
    (gsl-vector-free y)
    (cond ((= errno 0) result)
	  (else (error (gsl-strerror errno))))))

(define (blas-zgemv trans alpha A x beta y)
  (if (not (complex? alpha))
      (error "alpha must be a complex number"))
  (if (not (complex-matrix? A))
      (error "A must be a complex matrix"))
  (if (not (complex-vector? x))
      (error "x must be a complex vector"))
  (if (not (complex? beta))
      (error "beta must be a complex number"))
  (if (not (complex-vector? y))
      (error "y must be a complex vector"))
  (let* ((trans (cond ((eq? trans 'no-transpose) (CblasNoTrans))
		      ((eq? trans 'transpose) (CblasTrans))
		      ((eq? trans 'conjugate) (CblasConjTrans))
		      (else (error "unknown trans parameter"))))
	 (alpha (complex->gsl-complex alpha))
	 (a (matrix->gsl-matrix-complex a))
	 (x (vector->gsl-vector-complex x))
	 (beta (complex->gsl-complex beta))
	 (y (vector->gsl-vector-complex y))
	 (errno (gsl-blas-zgemv trans alpha a x beta y))
	 (result (gsl-vector-complex->vector y)))
    (gsl-complex-free alpha)
    (gsl-matrix-complex-free a)
    (gsl-vector-complex-free x)
    (gsl-complex-free beta)
    (gsl-vector-complex-free y)
    (cond ((= errno 0) result)
	  (else (error (gsl-strerror errno))))))


;;; Matrix - matrix multiplication
(define (blas-dgemm transA transB alpha A B beta C)
  (if (not (real? alpha))
      (error "alpha must be a real number"))
  (if (not (real-matrix? A))
      (error "A must be a real matrix"))
  (if (not (real-matrix? B))
      (error "B must be a real matrix"))
  (if (not (real? beta))
      (error "beta must be a real number"))
  (if (not (real-matrix? C))
      (error "C must be a real matrix"))
  (let* ((transA (cond ((eq? transA 'no-transpose) (CblasNoTrans))
		      ((eq? transA 'transpose) (CblasTrans))
		      ((eq? transA 'conjugate) (CblasConjTrans))
		      (else (error "unknown transA parameter"))))
	 (transB (cond ((eq? transB 'no-transpose) (CblasNoTrans))
		       ((eq? transB 'transpose) (CblasTrans))
		       ((eq? transB 'conjugate) (CblasConjTrans))
		       (else (error "unknown transB parameter"))))
	(A (matrix->gsl-matrix A))
	(B (matrix->gsl-matrix B))
	(C (matrix->gsl-matrix C))
	(errno (gsl-blas-dgemm transA transB alpha A B beta C))
	(result (gsl-matrix->matrix C)))
    (gsl-matrix-free A)
    (gsl-matrix-free B)
    (gsl-matrix-free C)
    (cond ((= errno 0) result)
	  (else (error (gsl-strerror errno))))))

(define (blas-zgemm transA transB alpha A B beta C)
  (if (not (complex? alpha))
      (error "alpha must be a complex number"))
  (if (not (complex-matrix? A))
      (error "A must be a complex matrix"))
  (if (not (complex-matrix? B))
      (error "B must be a complex matrix"))
  (if (not (complex? beta))
      (error "beta must be a complex number"))
  (if (not (complex-matrix? C))
      (error "C must be a complex matrix"))
  (let* ((transA (cond ((eq? transA 'no-transpose) (CblasNoTrans))
		      ((eq? transA 'transpose) (CblasTrans))
		      ((eq? transA 'conjugate) (CblasConjTrans))
		      (else (error "unknown transA parameter"))))
	 (transB (cond ((eq? transB 'no-transpose) (CblasNoTrans))
		       ((eq? transB 'transpose) (CblasTrans))
		       ((eq? transB 'conjugate) (CblasConjTrans))
		       (else (error "unknown transB parameter"))))
	 (A (matrix->gsl-matrix-complex A))
	 (B (matrix->gsl-matrix-complex B))
	 (C (matrix->gsl-matrix-complex C))
	 (errno (gsl-blas-zgemm transA transB alpha A B beta C))
	 (result (gsl-matrix-complex->matrix C)))
    (gsl-complex-free alpha)
    (gsl-matrix-complex-free A)
    (gsl-matrix-complex-free B)
    (gsl-complex-free beta)
    (gsl-matrix-complex-free C)
    (cond ((= errno 0) result)
	  (else (error (gsl-strerror errno))))))



(define (ddot x y)
  "x^T * y where x and y are real vectors."
  (if (not (and (uniform-vector? x)
		(uniform-vector? y)))
      (error "arguments must be uniform vectors"))
  (let ((x (vector->gsl-vector x))
	(y (vector->gsl-vector y)))
    (let ((result (gsl-blas-ddot x y)))
      (gsl-vector-free x)
      (gsl-vector-free y)
      (cadr result))))

(define (zdotu x y)
  "x^T * y where x and y are complex vectors."
  (if (not (and (uniform-vector? x)
		(uniform-vector? y)))
      (error "arguments must be uniform vectors"))
  (let ((x (vector->gsl-vector-complex (ensure-complex-array x)))
	(y (vector->gsl-vector-complex (ensure-complex-array y)))
	(z (gsl-complex-alloc))
	(errno (gsl-blas-zdotu x y z))
	(result (gsl-complex->complex z)))
    (gsl-vector-complex-free x)
    (gsl-vector-complex-free y)
    (gsl-vector-complex-free z)
    result))

(define (zdotc x y)
  "x^H * y where x and y are complex vectors."
  (if (not (and (uniform-vector? x)
		(uniform-vector? y)))
      (error "arguments must be uniform vectors"))
  (let ((x (vector->gsl-vector-complex (ensure-complex-array x)))
	(y (vector->gsl-vector-complex (ensure-complex-array y)))
	(z (gsl-complex-alloc))
	(errno (gsl-blas-zdotc x y z))
	(result (gsl-complex->complex z)))
    (gsl-vector-complex-free x)
    (gsl-vector-complex-free y)
    (gsl-vector-complex-free z)
    result))

(define (dot x y)
  (let ((x (array->uniform-array (ensure-vector x)))
	(y (array->uniform-array (ensure-vector y))))
    (let ((ops (list->array 2 (list (list ddot  zdotu)
				    (list zdotu zdotu))))
	  (p (if (equal? (array-prototype x) 0+i) 1 0))
	  (q (if (equal? (array-prototype y) 0+i) 1 0)))
      ((array-ref ops p q) x y))))


;;; Unfortunately the following functions do not accept complex
;;; arguments.
(define (real-poly-eval v x)
  (if (not (real-vector? v))
      (error "V must be a real vector"))
  (let* ((len (uniform-vector-length v))
	 (v (vector->gsl-vector v))
	 (result (gsl-poly-eval (gsl-vector-data v) len x)))
    (gsl-vector-free v)
    result))

(define (real-poly-solve v)
  (if (not (real-vector? v))
      (error "V must be a real vector"))
  (let* ((len (uniform-vector-length v))
	 (workspace (gsl-poly-complex-workspace-alloc len))
	 (z (gsl-vector-complex-alloc len))
	 (v (vector->gsl-vector v))
	 (errno (gsl-poly-complex-solve (gsl-vector-data v)
					len workspace
					(gsl-vector-complex-data z)))
	 (result (gsl-vector-complex->vector z)))
    (gsl-poly-complex-workspace-free workspace)
    (gsl-vector-free v)
    (gsl-vector-complex-free z)
    (cond ((= errno 0) result)
	  (else (error (gsl-strerror errno))))))
	   
